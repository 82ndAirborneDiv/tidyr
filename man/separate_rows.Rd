% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/separate-rows.R
\name{separate_rows}
\alias{separate_rows}
\title{Separate a collapsed column into multiple rows.}
\usage{
separate_rows(data, ..., sep = "[^[:alnum:].]+", convert = FALSE)
}
\arguments{
\item{data}{A data frame.}

\item{...}{A selection of columns. These arguments are passed to
\code{\link[tidyselect:vars_select]{tidyselect::vars_select()}} and are treated specially for
selection:\preformatted{* Calls and complex expressions are evaluated in the context.
  You cannot refer to data columns in these expressions.

* Bare symbols are evaluated in the data but not the context.
  You can only refer to data columns with bare symbols.

* In addition, `c()` and the `:` operators are also evaluated
  in the data (this is an exception to the rule above). Select
  all variables between x and z with `x:z`, exclude y with
  `-y`. You can refer to columns but not to objects from the
  context. If you need to refer to contextual objects, you can
  unquote them with the tidy eval operator `!!`.
}

For instance, \code{col1:col3} creates a selection that refers to data
objects, while \code{seq(start, end)} creates a selection that refers
to contextual objects.}

\item{sep}{Separator delimiting collapsed values.}

\item{convert}{If \code{TRUE} will automatically run
\code{\link[=type.convert]{type.convert()}} on the key column. This is useful if the column
names are actually numeric, integer, or logical.}
}
\description{
If a variable contains observations with multiple delimited values, this
separates the values and places each one in its own row.
}
\examples{

df <- data.frame(
  x = 1:3,
  y = c("a", "d,e,f", "g,h"),
  z = c("1", "2,3,4", "5,6"),
  stringsAsFactors = FALSE
)
separate_rows(df, y, z, convert = TRUE)
}
